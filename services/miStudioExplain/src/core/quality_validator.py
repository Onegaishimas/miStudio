"""
Quality Validator for miStudioExplain Service

Performs automated checks on the generated explanation to ensure quality.
"""

import logging
from typing import List, Dict, Tuple

logger = logging.getLogger(__name__)


class QualityValidator:
    """
    Validates the quality of a generated explanation against a set of criteria.
    """

    # Common phrases indicating the model refused to perform the task.
    REFUSAL_PHRASES = [
        "i cannot",
        "i am not able",
        "as an ai",
        "as a language model",
        "i am only a language model",
        "without more context",
        "i'm sorry, but",
    ]

    def __init__(self):
        logger.info("üîß QualityValidator initialized.")

    def validate(
        self,
        explanation_text: str,
        prioritized_features: List[str]
    ) -> Tuple[bool, List[str]]:
        """
        Runs a series of validation checks on the explanation text.

        Args:
            explanation_text: The text generated by the LLM.
            prioritized_features: The list of keywords the explanation should focus on.

        Returns:
            A tuple containing a boolean (True if valid, False otherwise) and
            a list of strings describing any validation failures.
        """
        logger.info("Performing quality validation...")
        failures = []

        # 1. Check for completeness (not empty or just whitespace)
        if not explanation_text or not explanation_text.strip():
            failures.append("Explanation is empty or contains only whitespace.")
            return False, failures

        explanation_lower = explanation_text.lower()

        # 2. Check for refusal phrases
        for phrase in self.REFUSAL_PHRASES:
            if phrase in explanation_lower:
                failures.append(f"Explanation contains a refusal phrase: '{phrase}'.")

        # 3. Check for relevance (must mention at least one prioritized feature)
        if prioritized_features:
            found_feature = False
            for feature in prioritized_features:
                if feature.lower() in explanation_lower:
                    found_feature = True
                    break
            if not found_feature:
                failures.append(
                    "Explanation does not appear to be relevant; it fails to mention "
                    f"any of the prioritized features: {prioritized_features}."
                )
        
        if failures:
            logger.warning(f"‚ùå Quality validation failed: {failures}")
            return False, failures
        else:
            logger.info("‚úÖ Quality validation passed.")
            return True, []